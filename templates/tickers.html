<html>
	<head>
		<!-- <meta http-equiv="refresh" content="1" /> -->
		<link rel="icon" href="data:,">
		<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.1/chartjs-plugin-zoom.min.js"></script>
		<script>
			function doFilter() {
				window.location.href = '/{{ticker}}?date=' + $("#date").val() + '&from_time=' + $("#from_time").val() + '&to_time=' + $("#to_time").val();
			}

		</script>
	</head>

	<div class="chart-wrapper">
		<h2 id="timesheader">
			<span id="ticker">{{ticker}}</span>
			<input type="text" id="date" value="{{date}}" size="7" />
			<input type="text" id="from_time" value="{{from_time}}" size="3" />
			<input type="text" id="to_time" value="{{to_time}}" size="3" />
			<button type="button" id="range_button" onclick="doFilter()">Select</button>
			| <input type="text" id="skipInterval" value="" size="2" /> <button id="resetInterval">res</button>
			<span id="timesContainer"></span>
			| <span id="low" style="color:red">{{data[ticker]['low']}}</span>
			| <span id="high" style="color: green">{{data[ticker]['high']}}</span>
		</h2>
		<canvas id="{{ticker}}"></canvas>
		<canvas id="RSIchart"></canvas>
	</div>

	<script>
		timesArr = [-1, 0, 180, 120, 60, 45, 30, 20, 15, 10, 5, 2, 1];
		timesArr.forEach(element => {
			let text = element + (element > 1 ? ' mins' : ' min');
			if (element === 0) {
				text = 'Open';
			} else if (element === -1) {
				text = 'Today';
			}
			a = $('<a href="#">' + text + '</a>');
			a.click( e => {e.preventDefault(); showChartMinsBack(element); return false} );
			$('#timesContainer').append(' | ')
			$('#timesContainer').append(a);
		});

		let DATAINTERVAL = 1;
		$('#skipInterval').blur( (e) => { DATAINTERVAL = parseInt(e.target.value) } );
		$('#skipInterval').keypress( (e) => { if (e.which == 13) { DATAINTERVAL = parseInt(e.target.value) } } );
		$('#resetInterval').click( (e) => { $('#skipInterval').val(1); $('#skipInterval').blur(); } )
		$('#ticker').click( (e) => { stockChart.resetZoom(); } );

		const exists = (what) => {
			try {
				tmp = eval(what);
				return (tmp !== 'undefined' && tmp !== 'null') ? true : false;
			} catch (e) {
				return false;
			}
		}

		const ticker = '{{ticker}}';
		let dataObj = {
			times: {{data[ticker]['times']|safe}},
			bids: {{data[ticker]['bids']}},
			asks: {{data[ticker]['asks']}},
			lasts: {{data[ticker]['lasts']}},
		};

		let RSIObj = {periods: 14, data: {times: [1], RSI: []}, previousAvgGain: 0.0, previousAvgLoss: 0.0}
		function calculateRSI(periods, data) {
			periods = 14;
			let newRSIObj = {periods: periods, data: {times:[1], RSI: []}, previousAvgGain: 0.0, previousAvgLoss: 0.0};
			newRSIObj.data.times = dataObj.times.slice(IDX);
			if (data.length < periods) {
				return newRSIObj;
			}
			let periodSumGain = 0.0;
			let periodSumLoss = 0.0;
			// let tgain = [0.0, 0.0, 0.06, 0.0, 0.72, 0.50, 0.27, 0.33, 0.42, 0.24, 0.0, 0.14, 0.0, 0.67, 0.0, 0.0, 0.03, 0.38, 0.0, 0.0, 0.57, 0.04, 0.0, 0.74, 0.0, 0.0, 0.0, 0.15, 0.04, 0.35, 0.0, 0.0, 0.47]
			// let tloss = [0.0, 0.25, 0.0, 0.54, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.19, 0.0, 0.42, 0.0, 0.0, 0.28, 0.0, 0.0, 0.19, 0.58, 0.0, 0.0, 0.54, 0.0, 0.67, 0.43, 1.33, 0.0, 0.0, 0.0, 1.15, 0.76, 0.0]
			for (const [i, n] of data.entries()) {
				let diff = parseFloat(Math.abs(n - data[i-1]));
				let gain = (n > data[i-1]) ? diff: 0.0;
				let loss = (n < data[i-1]) ? diff: 0.0;
				// let gain = (tgain[i] > 0.0) ? tgain[i] : 0.0;
				// let loss = (tloss[i] > 0.0) ? tloss[i] : 0.0;
				if (i < periods) {
					periodSumGain += gain;
					periodSumLoss += loss;
					newRSIObj.data.RSI.push(50);
				} else if (i == periods) {
					newRSIObj.previousAvgGain = periodSumGain / newRSIObj.periods;
					newRSIObj.previousAvgLoss = periodSumLoss / newRSIObj.periods;
					let rsi = 100.0;
					if (newRSIObj.previousAvgLoss > 0.0) {
						let rs = parseFloat(newRSIObj.previousAvgGain / newRSIObj.previousAvgLoss)
						rsi = parseFloat(100 - (100 / (1 + rs)).toFixed(4));
					}
					newRSIObj.data.RSI.push(rsi)
				} else {
					newRSIObj = addToRSI(newRSIObj, gain, loss)
					// let avgGain = ( (RSIObj.previousAvgGain * (RSIObj.periods-1)) + gain ) / RSIObj.periods;
					// let avgLoss = ( (RSIObj.previousAvgLoss * (RSIObj.periods-1)) + loss ) / RSIObj.periods;
					// let rsi = 100.0;
					// if (avgLoss > 0.0) {
					// 	let rs = parseFloat(RSIObj.previousAvgGain / RSIObj.previousAvgLoss)
					// 	rsi = parseFloat(100 - (100 / (1 + rs)).toFixed(4));
					// }
					// RSIObj.data.push(rsi);
					// RSIObj.previousAvgGain = avgGain;
					// RSIObj.previousAvgLoss = avgLoss;
				}
				// if (i == tgain.length) {
				// 	break;
				// }
			}
			// PERIOD=14; RSI = 100 - (100/(1+RS));  RS = avg.gain / avg.loss
			return newRSIObj;
		}

		function addToRSI(RSIObj, gain, loss) {
			let avgGain = ( (RSIObj.previousAvgGain * (RSIObj.periods-1)) + gain ) / RSIObj.periods;
			let avgLoss = ( (RSIObj.previousAvgLoss * (RSIObj.periods-1)) + loss ) / RSIObj.periods;
			let rsi = 100.0;
			if (avgLoss > 0.0) {
				let rs = parseFloat(RSIObj.previousAvgGain / RSIObj.previousAvgLoss)
				rsi = parseFloat(100 - (100 / (1 + rs)).toFixed(4));
			}
			RSIObj.data.RSI.push(rsi);
			RSIObj.previousAvgGain = avgGain;
			RSIObj.previousAvgLoss = avgLoss;
			return RSIObj;
		}

		function getExponentialSmoothing(data) {
			let forcastArr = [0];
			const alpha = 0.2;
			for (const [i, n] of data.entries()) {
				if (i == 0) { continue; }
				if (i == 1) {
					forcastArr.push (data[i-1] );
				} else {
					forcastArr.push( alpha*data[i-1] + (1 - alpha)*forcastArr[i-1] );
				}
			}
			return forcastArr;
		}

		function getChartData(tbal) {
			if ( !exists(tbal) ) {
				return {};
			}
			let data = tbal;
			if (DATAINTERVAL > 1) {
				data = {times: [], bids: [], asks: [], lasts: []};
				for (const [k, v] of Object.entries(tbal)) {
					for (const [i, n] of v.entries()) {
						if (i%DATAINTERVAL == 0) {
							data[k].push(n);
						}
					}
				}
			}
			return {
				labels: data.times,
				datasets: [
					{
						label: 'bid',
						data: data.bids,
						borderWidth: 1,
						yAxisID: 'y1',
						borderColor: "green",
					},
					{
						label: 'ask',
						data: data.asks,
						borderWidth: 1,
						yAxisID: 'y1',
						borderColor: "red",
					},
					{
						label: 'last',
						data: data.lasts,
						borderWidth: 1,
						yAxisID: 'y1',
						borderColor: "#FFC300",
					},
				],
			};
		}

		let chartOptions = {
			responsive: true,
			stacked: true,
			//maintainAspectRatio: false,
			animation: {
				duration: 0
			},
			scales: {
				y: {
					type: 'linear',
					position: 'left',
					// min: 33,
					// max: 35,
					display: false,
					grid: {
						drawOnChartArea: false
					}
				},
				y1: {
					type: 'linear',
					position: 'right',
				},
			},
			plugins: {
				// title: {
				// 	display: true,
				// 	text: ticker
				// },
				zoom: {
					pan: {
						enabled: false,
						mode: 'xy',
					},
					zoom: {
						wheel: {
							enabled: false,
						},
						pinch: {
							enabled: false
						},
						drag: {
							enabled: false
						},
						mode: 'xy',
					},
				},
				tooltip: {
					enabled: false
				},
			},
            elements:{
                point:{
                    borderWidth: 0,
                    radius: 1,
                    //backgroundColor: 'rgba(0,0,0,0)'
                }
            },
			legend: {
				onClick: (evt, item, legend) => {
					let index = item.datasetIndex;
					if (this.chart.getDataVisibility(index)) {
						this.chart.hide(index);
					} else {
						this.chart.show(index);
					}
				},
				onHover: (evt, item, legend) => {
					//console.log('onhover');
					//document.getElementById("WAL").style.cursor = 'pointer';
        		},
			},
		};

		function getChartConfig(type, data, options, plugins) {
			return {
				type: type,
				data: data,
				options: options,
				plugins: plugins
			};
		}

		// Chart.defaults.global.showTooltips = false;
		const ctx = document.getElementById('{{ticker}}');
		let stockChart = new Chart(ctx, getChartConfig('line', getChartData(dataObj), chartOptions, []));

		const getNewTickerData = async (url) => {
			const response = await fetch(url, {
			"headers": {
				"accept": "*/*",
				"content-type": "application/json",
			},
			"method": "GET"
			});
			return await response.json();
		}


		function getDataFromIndex(idx) {
			if ( !exists(idx) ) {
				idx = 0;
			}
			return {
				times: dataObj.times.slice(idx),
				bids: dataObj.bids.slice(idx),
				asks: dataObj.asks.slice(idx),
				lasts: dataObj.lasts.slice(idx)
			};
		}

		const updateChartsWithNewData = async () => {
			if (dataObj.times.length == 0) {
				return;
			}
			end = dataObj.times[dataObj.times.length - 1];
			begin = end.split(':');
			begin[2] = parseInt(begin[2]) + 1;  // want 1 second more
			
			url = ticker + '?from_time=' + begin.join(':');
			newData = await getNewTickerData(url);

			if (newData[ticker].times.length > 0) {
				// ticker price data and chart
				dataObj.times = dataObj.times.concat(newData[ticker].times)
				dataObj.bids = dataObj.bids.concat(newData[ticker].bids);
				dataObj.asks = dataObj.asks.concat(newData[ticker].asks);
				dataObj.lasts = dataObj.lasts.concat(newData[ticker].lasts);
				data = getDataFromIndex(IDX);
				$('#low').text().replace(newData[ticker].low)
				$('#high').text().replace(newData[ticker].high)
				stockChart.destroy();
				stockChart = new Chart(ctx, getChartConfig('line', getChartData(data), chartOptions, []));

				// RSI data and chart
				RSIObj = calculateRSI(RSIObj.periods, data.lasts);
				rsiChart.destroy();
				rsiChart = new Chart($('#RSIchart'), getChartConfig('line', getRSIChartData(RSIObj.data), RSIChartOptions, [horizontalLine]));
			}
		}

		let IDX = 0;
		let I = 1;
		function runUpdateInterval() {
			setTimeout(runUpdateInterval, I*1000);
			updateChartsWithNewData();
		}

		runUpdateInterval();



		function showChartMinsBack(minsBack) {
			last = dataObj.times[dataObj.times.length - 1];
			hms = last.split(':');
			let hrs = parseInt(hms[0])
			let mins = parseInt(hms[1]);
			let secs = parseInt(hms[2]);
			let openSince = 9*60 + 30;   // Open time, 9:30 AM
			const oldIDX = IDX;

			if ( minsBack === 0 && hrs*60 + mins >= openSince) {
				minsBack = hrs*60 + mins - openSince;
			}

			if (minsBack > 0) {
				backAsSeconds = (hrs*60 + mins - minsBack)*60 + secs;
				for (const [i, value] of dataObj.times.entries()) {
					let time = value.split(':');
					let asSecs = parseInt(time[0])*3600 + parseInt(time[1]*60) + parseInt(time[2]);
					if (asSecs > backAsSeconds) {
						IDX = i;
						break;
					}
				}
			}
			if (IDX !== oldIDX) {
				data = getDataFromIndex(IDX);
				stockChart.destroy();
				stockChart = new Chart(ctx, getChartConfig('line', getChartData(data), chartOptions, []));

				rsiData = RSIObj.data.rsi.slice(IDX);
				// RSIObj = calculateRSI(RSIObj.periods, dataObj.lasts.slice(IDX));
				rsiChart.destroy();
				rsiChart = new Chart($('#RSIchart'), getChartConfig('line', getRSIChartData(RSIObj.data), RSIChartOptions, [horizontalLine]));
			}
		}


		const customCanvasBackgroundColor = {
			id: 'customCanvasBackgroundColor',
			beforeDraw: (chart, args, options) => {
				const {ctx} = chart;
				ctx.save();
				ctx.globalCompositeOperation = 'destination-over';
				ctx.fillStyle = options.color || '#99ffff';
				ctx.fillRect(30, 30, chart.width-50, chart.height-700);
				ctx.restore();
			}
		};

		let RSIChartOptions = {
			responsive: true,
			stacked: true,
			animation: {
				duration: 0
			},
			scales: {
				y: {
					type: 'linear',
					position: 'right',
				},
			},
			plugins: {
				tooltip: {
					enabled: true
				},
			},
            elements:{
                point:{
                    borderWidth: 1,
                    radius: 1,
                },
				line: {
					tension: 0
				}
            },
		};

		RSIObj = calculateRSI(RSIObj.periods, dataObj.lasts);
		const getRSIChartData = (data) => {
			let overbought = [...new Array(data.times.length)].map(()=>70);
			let oversold = [...new Array(data.times.length)].map(()=>30);
			let rsiChartData = {
				labels: dataObj.times.slice(IDX),
				datasets: [
					{label: 'rsi', data: data.RSI, borderWidth: 1, borderColor: '#ded3bf'},
					//{label: 'overbought', data: overbought, borderWidth: 1, borderColor: 'green'},
					//{label: 'oversold', data: oversold, borderWidth: 1, borderColor: 'red'},
					{label: 'ExpSm', data: getExponentialSmoothing(data.RSI), borderWidth: 1, borderColor: '#b59f02'},
				]
			}
			return rsiChartData;
		}


		const horizontalLine = {
			id: 'horizontalLine',
			beforeDatasetsDraw: ( chart, args, options ) => {
				const { ctx, chartArea: {top, right, bottom, left, width, height}, scales: {x, y} } = chart;
				ctx.save();
				// draw line
				ctx.strokeStyle = 'green';
				//ctx.setLineDash([50, 50]);
				ctx.strokeRect(left, y.getPixelForValue(30), width, 0);
				
				ctx.strokeStyle = 'red';
				ctx.strokeRect(left, y.getPixelForValue(70), width, 0);

				ctx.restore();
			},
		};

		rsiChart = new Chart($('#RSIchart'), getChartConfig('line', getRSIChartData(RSIObj.data), RSIChartOptions, [horizontalLine]));

	</script>
</html>