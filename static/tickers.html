<html>
	<head>
		<!-- <meta http-equiv="refresh" content="1" /> -->
		<link rel="icon" href="data:,">
		<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.1/chartjs-plugin-zoom.min.js"></script>
		<script>
			function doFilter() {
				window.location.href = '/{{ticker}}?from_time=' + $("#from_time").val() + '&to_time=' + $("#to_time").val();
			}

		</script>
	</head>

	<div class="chart-wrapper">
		<h2 id="timesheader">
			<span>{{ticker}}</span>
			<input type="text" id="from_time" value="" size="3" />
			<input type="text" id="to_time" value="" size="3" />
			<button type="button" id="range_button" onclick="doFilter()">Select</button>
			| <input type="text" id="skipInterval" value="" size="2" /> <button id="resetInterval">res</button>
			<span id="timesContainer"></span>
			| <span id="low" style="color:red">{{data[ticker]['low']}}</span>
			| <span id="high" style="color: green">{{data[ticker]['high']}}</span>
		</h2>
		<canvas id="{{ticker}}"></canvas>
	</div>

	<script>
		timesArr = [-1, 0, 180, 120, 60, 45, 30, 15, 10, 5, 2, 1];
		timesArr.forEach(element => {
			let text = element + (element > 1 ? ' mins' : ' min');
			if (element === 0) {
				text = 'Open';
			} else if (element === -1) {
				text = 'Today';
			}
			a = $('<a href="#">' + text + '</a>');
			a.click( e => {e.preventDefault(); showChartMinsBack(element); return false} );
			$('#timesContainer').append(' | ')
			$('#timesContainer').append(a);
		});

		let DATAINTERVAL = 1;
		$('#skipInterval').blur( (e) => { DATAINTERVAL = parseInt(e.target.value) } );
		$('#skipInterval').keypress( (e) => { if (e.which == 13) { DATAINTERVAL = parseInt(e.target.value) } } );
		$('#resetInterval').click( (e) => { $('#skipInterval').val(1); $('#skipInterval').blur(); } )

		const ticker = '{{ticker}}';
		let dataObj = {
			times: {{data[ticker]['times']|safe}},
			bids: {{data[ticker]['bids']}},
			asks: {{data[ticker]['asks']}},
			lasts: {{data[ticker]['lasts']}},
		};

		let RSIPeriod = 14;
		function calculateRSI(periods) {
			let periodSumGain = 0;
			let periodSumLoss = 0;
			let previousAvgGain = 0;
			let previousAvgLoss = 0;
			let RSI = [];
			for (const [i, n] of dataObj.lasts.entries()) {
				if (i==0) { continue; }
				if (i < periods) {
					periodSumGain += (n > dataObj.lasts[i-1]) ? n : 0;
					periodSumLoss += (n < dataObj.lasts[i-1]) ? n : 0;
				} else if (i == periods) {
					previousAvgGain = periodSumGain / periods;
					previousAvgLoss = periodSumLoss / periods;
					let rs = previousAvgGain / previousAvgLoss;
					let rsi = 100 - (100 / (1 + rs));
					RSI.push(rsi);
				} else {
					let diff = Math.abs(n - dataObj.lasts[i-1]);
					let gain = (n > dataObj.lasts[i-1]) ? diff: 0;
					let loss = (n < dataObj.lasts[i-1]) ? diff: 0;
					let avgGain = ( (previousAvgGain * (periods-1)) + gain ) / periods;
					let avgLoss = ( (previousAvgLoss * (periods-1)) + loss ) / periods;
					let rs = avgGain / avgLoss;
					let rsi = (100 - (100 / (1 + rs))).toFixed(2);
					RSI.push(rsi);
					previousAvgGain = avgGain;
					previousAvgLoss = avgLoss;
				}
			}
			// PERIOD=14; RSI = 100 - (100/(1+RS));  RS = avg.gain / avg.loss
			return RSI;
		}

		function getChartData(tbal) {
			if ( !exists(tbal) ) {
				return {};
			}
			let data = tbal;
			if (DATAINTERVAL > 1) {
				data = {times: [], bids: [], asks: [], lasts: []};
				for (const [k, v] of Object.entries(tbal)) {
					for (const [i, n] of v.entries()) {
						if (i%DATAINTERVAL == 0) {
							data[k].push(n);
						}
					}
				}
			}
			return {
				labels: data.times,
				datasets: [
					{
						label: 'bid',
						data: data.bids,
						borderWidth: 1,
						yAxisID: 'y1',
						borderColor: "green",
					},
					{
						label: 'ask',
						data: data.asks,
						borderWidth: 1,
						yAxisID: 'y1',
						borderColor: "red",
					},
					{
						label: 'last',
						data: data.lasts,
						borderWidth: 1,
						yAxisID: 'y1',
						borderColor: "#FFC300",
					},
				],
			};
		}

		let chartOptions = {
			responsive: true,
			stacked: true,
			//maintainAspectRatio: false,
			animation: {
				duration: 0
			},
			plugins: {
				title: {
					display: true,
					text: ticker
				}
			},
			scales: {
				y: {
					type: 'linear',
					position: 'left',
					// min: 33,
					// max: 35,
					display: false,
					grid: {
						drawOnChartArea: false
					}
				},
				y1: {
					type: 'linear',
					position: 'right',
				},
			},
			plugins: {
				zoom: {
					pan: {
						enabled: false,
						mode: 'xy',
					},
					zoom: {
						wheel: {
							enabled: true,
						},
						pinch: {
							enabled: true
						},
						drag: {
							enabled: true
						},
						mode: 'xy',
					},
				},
				tooltip: {
					enabled: false
				},
			},

		};

		function getChartConfig(type, data, options) {
			return {
				type: type,
				data: data,
				options: options,
			};
		}

		// Chart.defaults.global.showTooltips = false;
		const ctx = document.getElementById('{{ticker}}');
		let stockChart = new Chart(ctx, getChartConfig('line', getChartData(dataObj), chartOptions));

		const getNewTickerData = async (url) => {
			const response = await fetch(url, {
			"headers": {
				"accept": "*/*",
				"content-type": "application/json",
			},
			"method": "GET"
			});
			return await response.json();
		}

		function exists(what) {
			return (what !== 'undefined' && what !== 'null') ? true : false;
		}

		function getDataFromIndex(idx) {
			if ( !exists(idx) ) {
				idx = 0;
			}
			return {
				times: dataObj.times.slice(idx),
				bids: dataObj.bids.slice(idx),
				asks: dataObj.asks.slice(idx),
				lasts: dataObj.lasts.slice(idx)
			};
		}

		const updateChartWithNewData = async () => {
			if (dataObj.times.length == 0) {
				return;
			}
			end = dataObj.times[dataObj.times.length - 1];
			begin = end.split(':');
			begin[2] = parseInt(begin[2]) + 1;  // want 1 second more
			
			url = ticker + '?from_time=' + begin.join(':');
			newData = await getNewTickerData(url);

			if (newData[ticker].times.length > 0) {
				dataObj.times = dataObj.times.concat(newData[ticker].times)
				dataObj.bids = dataObj.bids.concat(newData[ticker].bids);
				dataObj.asks = dataObj.asks.concat(newData[ticker].asks);
				dataObj.lasts = dataObj.lasts.concat(newData[ticker].lasts);
				
				data = getDataFromIndex(IDX);
				$('#low').text().replace(newData[ticker].low)
				$('#high').text().replace(newData[ticker].high)
				stockChart.destroy();
				stockChart = new Chart(ctx, getChartConfig('line', getChartData(data), chartOptions));
			}
		}

		let IDX = 0;
		let I = 1;
		function runUpdateInterval() {
			setTimeout(runUpdateInterval, I*1000);
			updateChartWithNewData();
		}

		runUpdateInterval();



		function showChartMinsBack(minsBack) {
			last = dataObj.times[dataObj.times.length - 1];
			hms = last.split(':');
			let hrs = parseInt(hms[0])
			let mins = parseInt(hms[1]);
			let secs = parseInt(hms[2]);
			let openSince = 9*60 + 30;   // Open time, 9:30 AM
			const oldIDX = IDX;

			if ( minsBack === 0 && hrs*60 + mins >= openSince) {
				minsBack = hrs*60 + mins - openSince;
			}

			if (minsBack > 0) {
				backAsSeconds = (hrs*60 + mins - minsBack)*60 + secs;
				for (const [i, value] of dataObj.times.entries()) {
					let time = value.split(':');
					let asSecs = parseInt(time[0])*3600 + parseInt(time[1]*60) + parseInt(time[2]);
					if (asSecs > backAsSeconds) {
						IDX = i;
						break;
					}
				}
			}
			if (IDX !== oldIDX) {
				data = getDataFromIndex(IDX);
				stockChart.destroy();
				stockChart = new Chart(ctx, getChartConfig('line', getChartData(data), chartOptions));
			}
		}
	</script>
</html>